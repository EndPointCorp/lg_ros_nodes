* start/stop a process(es)
* send stop/cont signals to process(es)
* show/hide/move window(s)
* fire events when things happen(?):
* * startup/shutdown
* * respawn
* * activation/deactivation

WindowGeometry
+ WindowGeometry(x, y, w, h)
+ ~from_viewport(viewport_id)
+ ~from_scene(scene_window)

ManagedWindow
+ ManagedWindow(w_class, w_name, w_instance)
+ set_visibility(bool)
+ set_geometry(geometry)
+ offset_geometry(geometry)
+ use_viewport(id)
+ converge()

ProcessState (message type)
+ state
+ STOPPED=0
+ RUNNING=1
+ ACTIVE=2

ManagedProcess
+ ManagedProcess(cmd, activity, viewport, window, suspend)
+ consume_scene(scene)
+ get_state(state)
+ set_state(state)


earth_proc_route = rospy.Publisher('/my_earth_node/proc', ProcessState)
activate_earth_msg = ProcessState(state=ProcessState.ACTIVE)
earth_proc_route.publish(activate_earth_msg)


viewport = rospy.get_param('~viewport', None)
earth_window = ManagedWindow(w_name='Google Earth')
earth_window.use_viewport(viewport)
earth_proc = ManagedProcess(
    cmd=['/opt/google/earth/free/googleearth-bin'],
    activity='earth',
    viewport=viewport,
    window=earth_window,
    suspend=True
)
earth_proc.set_state(ProcessState.ACTIVE)
def scene_callback(scene):
    earth_proc.consume_scene(scene)


viewport = rospy.get_param('~viewport', None)
video_window = ManagedWindow(w_name='Video Window')
video_window.use_viewport(viewport)
video_proc = ManagedProcess(
    cmd=['/usr/bin/mplayer'],
    activity='video',
    viewport=viewport,
    window=window
)
video_proc.set_state(ProcessState.RUNNING)
def scene_callback(scene):
    video_proc.consume_scene(scene)


@ManagedProcess
def consume_scene(self, scene):
    my_activity = self.activity
    my_viewport = self.viewport
    my_window = self.window

    def match_window(window):
        return window.activity == my_activity and window.presentation_viewport == my_viewport

    matches = filter(match_window, scene.windows)

    def consume_window(window):
        self.set_state(ProcessState.ACTIVE)
        self.window.set_geometry(WindowGeometry.from_scene(window))
        self.window.set_visibility(True)
        self.window.converge()

    if len(matches > 0):
        map(consume_window, matches)
    else:
        self.set_state(ProcessState.RUNNING)
        self.window.set_visiblity(False)
        self.window.converge()


parameters from roslaunch xml file:
/viewport/center : {"x": 0, "y": 0, "w": 640, "h": 480}
/viewport/left_one : {"x": 0, "y": 480, "w": 640, "h": 480}
/viewport/right_one : {"x": 0, "y": 960, "w": 640, "h": 480}
